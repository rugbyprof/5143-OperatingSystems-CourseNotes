\newglossaryentry{heapds}{
    name=heap data structure,
    description=A type of data structure that efficiently implements a priority queue using a binary structure in an array. It can also be used to sort numbers
}

\newglossaryentry{heapmemory}{
    name=heap memory,
    description=A type of memory that is typically associated with dynamically allocated data, and exists throughout the lifetime of your program
}

\newglossaryentry{prioqueue}{
    name=priority queue,
    description=A queue like data structure in which an element with high priority gets preference (removed or served) before an element with lower priority
}

\newglossaryentry{bintree}{
    name=binary tree,
    description=A binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child
}

\newglossaryentry{heapsort}{
    name=heapsort,
    description=Sorting values using a binary heap by inserting the values into a heap and then removing the items 1 by 1 
}

\newglossaryentry{complete}{
    name=complete,
    description={In terms of a binary tree, All levels except possibly the last one (deepest) are fully filled, and, if the last level of the tree is not complete, the nodes of that level are filled from left to right}
}

\newglossaryentry{acyclic}{
    name=acyclic,
    description={In terms of a graph, acyclic means that there are no cycles in the graph}
}

\newglossaryentry{undgraph}{
    name=undirected graph,
    description={In a graph, G = (V, E), none of the edges have an "orientation" (no direction associated with the edge). This means
    that we can traverse an edge $A-B$ from $A \rightarrow B$ or from $B \rightarrow A$. Given a directed edge (one with orientation) and an edge $A \rightarrow B$, we can only traverse this edge in that direction, and \textbf{not} from $B \rightarrow A$}
}


\newglossaryentry{marytree}{
    name=m-ary tree,
    description={In graph theory, an m-ary tree (also known as k-ary or k-way tree) is a rooted tree in which each node has no more than m children. A binary tree is the special case where m = 2, and a ternary tree is another case with m = 3 that limits its children to three}
}

\newglossaryentry{trietree}{
    name=trie,
    description={In computer science, a trie, also called digital tree or prefix tree, is a kind of search tree—an ordered tree data structure used to store a dynamic set or associative array where the keys are usually strings. Unlike a binary search tree, no node in the tree stores the key associated with that node; instead, its position in the tree defines the key with which it is associated; i.e., the value of the key is distributed across the structure. All the descendants of a node have a common prefix of the string associated with that node, and the root is associated with the empty string. Keys tend to be associated with leaves, though some inner nodes may correspond to keys of interest. Hence, keys are not necessarily associated with every node}
}

\newglossaryentry{btree}{
    name=b-tree,
    description={In computer science, a B-tree is a self-balancing tree data structure that maintains sorted data and allows searches, sequential access, insertions, and deletions in logarithmic time. The B-tree generalizes the binary search tree, allowing for nodes with more than two children. Unlike other self-balancing binary search trees, the B-tree is well suited for storage systems that read and write relatively large blocks of data, such as disks. It is commonly used in databases and file systems}
}

\newglossaryentry{rtree}{
    name=r-tree,
    description={R-trees are tree data structures used for spatial access methods, i.e., for indexing multi-dimensional information such as geographical coordinates, rectangles or polygons. The R-tree was proposed by Antonin Guttman in 1984 and has found significant use in both theoretical and applied contexts. A common real-world usage for an R-tree might be to store spatial objects such as restaurant locations or the polygons that typical maps are made of: streets, buildings, outlines of lakes, coastlines, etc. and then find answers quickly to queries such as "Find all museums within 2 km of my current location", "retrieve all road segments within 2 km of my location" (to display them in a navigation system) or "find the nearest gas station" (although not taking roads into account). The R-tree can also accelerate nearest neighbor search for various distance metrics, including great-circle distance}
}

\newglossaryentry{tcomplex}{
    name=time complexity,
    description={In computer science, the time complexity is the computational complexity that describes the amount of computer time it takes to run an algorithm. Time complexity is commonly estimated by counting the number of elementary operations performed by the algorithm, supposing that each elementary operation takes a fixed amount of time to perform. Thus, the amount of time taken and the number of elementary operations performed by the algorithm are taken to differ by at most a constant factor}
}

\newglossaryentry{spacecomplex}{
name=space complexity,
description={The space complexity of an algorithm or a computer program is the amount of memory space required to solve an instance of the computational problem as a function of characteristics of the input. It is the memory required by an algorithm to execute a program and produce output}
}

\newglossaryentry{asymptotic}{
name=asymptotic notation,
description={ Big O notation is a mathematical notation that describes the limiting behavior of a function when the argument tends towards a particular value or infinity. Big O is a member of a family of notations invented by Paul Bachmann,[1] Edmund Landau,[2] and others, collectively called Bachmann–Landau notation or asymptotic notation}
}

\newglossaryentry{treetraversal}{
name=tree traversal,
description={Tree traversal (also known as tree search and walking the tree) is a form of graph traversal and refers to the process of visiting (checking and/or updating) each node in a tree data structure, exactly once. Such traversals are classified by the order in which the nodes are visited. The following algorithms are described for a binary tree, but they may be generalized to other trees as well}
}


\newglossaryentry{inordersucc}{
name=in order successor,
description={In a binary search tree, the in order successor of some node \textit{N}, can also be defined as the node with the smallest key greater than the key of \textit{N}. Or it is smallest value in the right sub-tree of node \textit{N}}
}

\newglossaryentry{inorderpred}{
name=in order predecessor,
description={In a binary search tree, the in order predecessor of some node \textit{N}, can also be defined as the node with the largest key smaller than the key of \textit{N}. Or it is largest value in the left sub-tree of node \textit{N}}
}




\newglossaryentry{term}{
name=What Shows,
description={}
}